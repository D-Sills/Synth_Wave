local audio_manager = require("scripts.modules.audio_manager")


-- go.property("movementSpeed", 200)
go.property("max_health", 3)

-- below values in beats
go.property("shootCooldown", 0.2)
go.property("invulnerabilityTime", 2) -- idk if needed

local active_bullets = {}

function init(self)
	--msg.post("main:/camera", "follow", { target = hash("level/#player"), lerp = 0.7, horizontal = true, vertical = true, immediate = true })
	msg.post("gui", "register")
	--msg.post("gui", "register_analog", { id = "analog", radius = 80 })
	msg.post("gui", "register_analog", { id = "analog", radius = 80 })
	msg.post("gui", "register_button", { id = "shoot_button" })
	print("player init")
	self.velocity = vmath.vector3()
	audio_manager.subscribe(msg.url())
	
	self.time_since_last_shot = 0 
	self.hp = self.max_hp
	self.is_invulnerable = false
    self.invuln_timer = 0
	self.should_flash = false

end



function update(self, dt)
	-- movement
	--go.set_position(go.get_position() + self.velocity * dt)
	--go.set_position(go.get_position("weapon") + self.velocity * dt, "weapon")


	-- fire rate
	if self.time_since_last_shot >= 0 then
		self.time_since_last_shot = self.time_since_last_shot - dt -- maybe beats but feels bad like that (OwO)-b
	end
    
    -- invulnerability
	--if self.is_invulnerable then
    --    self.invuln_timer = self.invuln_timer - dt
    --    if self.invuln_timer <= 0 then
    --        self.is_invulnerable = false
    --    end
    --end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("beat") then
        if self.is_invulnerable then
            if self.invuln_beats_left > 0 then
                self.invuln_beats_left = self.invuln_beats_left - 1
            end

            if self.invuln_beats_left <= 0 then
                self.is_invulnerable = false
                self.should_flash = false
                go.set(".", "tint", vmath.vector4(1, 1, 1, 1))  -- Reset to normal color
            end
        end

        if self.should_flash then
            -- Alternate the tint color for flashing
            local current_tint = go.get(".", "tint")
            local new_tint = current_tint.w == 1 and vmath.vector4(1, 0, 0, 0.5) or vmath.vector4(1, 1, 1, 1)
            go.set(".", "tint", new_tint)
		end
	elseif message_id == hash("onscreen_button") and message.id == hash("shoot_button") and message.released then
		if self.time_since_last_shot <= 0 then
			local rating = audio_manager.handle_player_action()
			        -- Calculate the forward direction
			-- Assume the 'forward' direction is up the screen in local space (0, 1, 0)
			local base_forward_vector = vmath.vector3(0, 1, 0)
			
			-- Get the rotation of the weapon game object as a quaternion
			local weapon_rotation_quat = go.get_rotation("/weapon#weapon")
			
			-- Rotate the base forward vector by the weapon's rotation to get the forward vector in world space
			local forward_vector = vmath.rotate(weapon_rotation_quat, base_forward_vector)
			
			-- Define the offset distance in front of the player where the projectile will spawn
			local offset_distance = 50
			-- Make sure to get the weapon's world position if the weapon sprite is a separate game object
			local weapon_position = go.get_world_position("/weapon#weapon")
			local spawn_position = weapon_position + forward_vector * offset_distance
			
			-- Create the laser projectile from the factory
			local id = factory.create("#laserfactory", spawn_position, weapon_rotation_quat)
			
			-- Projectile movement logic
			local projectile_speed = 500 -- Adjust the speed as needed
			local move_distance = 1500 -- Adjust based on how far you want the projectile to go
			local target_position = spawn_position + forward_vector * move_distance
			local travel_time = move_distance / projectile_speed
			
			audio_manager.play_sound_effect("Combat/LaserSmall")
			
			go.animate(id, "position", go.PLAYBACK_ONCE_FORWARD, target_position, go.EASING_LINEAR, travel_time, 0, function()
			    go.delete(id) -- Delete the projectile once it reaches the target position
			end)
			
			if rating == "Bad" then
			
			elseif rating == "Good" then 
				
			elseif rating == "Perfect" then
	
			end
			
			self.time_since_last_shot = self.shootCooldown
		else
			print("Can't shoot yet, cooldown active!")
		end
		
--[[ 	elseif message_id == hash("onscreen_analog") and message.id == hash("analog") then
		-- handle movement
		print ("analogL")
		if message.released then
			self.velocity.x = 0
			self.velocity.y = 0
		else
			self.velocity.x = message.x * self.movementSpeed
			self.velocity.y = message.y * self.movementSpeed
		end ]]
	elseif message_id == hash("onscreen_analog") and message.id == hash("analog") then
		-- Handle instant turning

            -- Calculate the angle based on the right analog stick input
        local angle = math.atan2(message.y, message.x) - math.pi / 2
        local target_rotation = vmath.quat_rotation_z(angle)
        go.set_rotation(target_rotation, "/weapon#weapon") 
        
        
	elseif message_id == hash("take_damage") then
		if not self.is_invulnerable then
			self.hp = self.hp - message.damage
			
			if self.hp <= 0 then
				-- Handle player death (e.g., end game, restart level)
				go.delete()
			else
				-- Begin invulnerability period
				self.is_invulnerable = true
				self.invuln_timer = self.invuln_duration
				-- Add visual or audio feedback for taking damage
			end
		end
	
	end
end

function final(self)
	msg.post("onscreen", "unregister")
	audio_manager.unsubscribe(msg.url())
end